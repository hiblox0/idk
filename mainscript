getgenv().JuliMade = {
    Aimbot = {
        Enabled = true,
        Keybind  = 'C', -- Aimbot toggle key
        hot = 'toggle', -- hold or toggle for aimbot
        Hitpart = 'HumanoidRootPart', -- Default hit part for aimbot
        ['Prediction'] = {
            X = 0.143,
            Y = 0.1,
        },
        SmoothnessEnabled = false, -- Enable or disable smoothness
        Smoothness = 0.1, -- Add smoothness factor (0.1 = 10% of the way)
        DistancePredictionEnabled = false, -- Enable or disable distance-based prediction
        MaxDistance = 1000, -- Maximum distance for prediction adjustment
        BasePrediction = 0.2, -- Base prediction value
    },
    Fly = {
        FlyEnabled = true,
        FlyKeybind = "X", -- Default key to toggle fly
        FlySpeed = 300, -- Fly speed
    },
    Esp = {
        EspEnabled = false, -- Enable ESP
        EspColor = Color3.fromRGB(0, 0, 255), -- ESP color
    },
    Extra = {
        Noclip = true, -- Enable Noclip
        ThroughtWalls = false, -- Enable Throught Walls (renamed from ThroughtFloors)
        AutoClicker = {
            Enabled = false, -- AutoClicker enabled/disabled
            Keybind = 'V', -- Keybind to toggle the auto clicker
            Mode = 'toggle', -- 'hold' or 'toggle' for auto clicker
            Delay = 0.1, -- Delay between clicks in seconds
            KnifeCheck = true -- Enable knife check
        }
    }
}

-- Avoid multiple executions by checking if the script has already run
if getgenv().AimbotRan then
    getgenv().JuliMade = getgenv().JuliMade -- Reinitialize settings on execution
else
    getgenv().AimbotRan = true
end

-- Services
local RunService = game:GetService('RunService')
local Workspace = game:GetService('Workspace')
local Players = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')
local Chat = game:GetService("Chat") -- Service for handling chat

-- Variables
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()
local Player = nil -- Target player for aimbot
local BodyGyro, BodyVelocity -- Components for fly mode
local flying = false -- Track if flying is active

-- ESP Functionality
local function createEsp(Player)
    if not Player.Character then return end
    local highlight = Player.Character:FindFirstChildOfClass("Highlight")
    if not highlight then
        highlight = Instance.new("Highlight")
        highlight.Adornee = Player.Character
        highlight.FillColor = getgenv().JuliMade.Esp.EspColor
        highlight.OutlineColor = Color3.new(0, 0, 0) -- Outline color
        highlight.Parent = Player.Character
    end
end

-- Remove ESP
local function removeEsp(Player)
    if not Player.Character then return end
    local highlight = Player.Character:FindFirstChildOfClass("Highlight")
    if highlight then
        highlight:Destroy()
    end
end

-- Enable/Disable ESP for all players
local function updateEsp()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            if getgenv().JuliMade.Esp.EspEnabled then
                if player.Character then
                    createEsp(player)
                end
                player.CharacterAdded:Connect(function(char)
                    wait(1) -- Wait for character to fully load
                    createEsp(player)
                end)
            else
                removeEsp(player)
            end
        end
    end
end

-- Call updateEsp when player joins
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        updateEsp()
    end)
end)

-- Call updateEsp on existing players
updateEsp()

-- Aimbot Functionality
local GetClosestPlayer = function() -- Optimized GetClosestPlayer function
    local ClosestDistance, ClosestPlayer = 100000, nil
    for _, Player : Player in pairs(Players:GetPlayers()) do
        if Player.Name ~= LocalPlayer.Name and Player.Character and Player.Character:FindFirstChild('HumanoidRootPart') then
            local Root, Visible = Camera:WorldToScreenPoint(Player.Character.HumanoidRootPart.Position)
            if not Visible then continue end
            Root = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(Root.X, Root.Y)).Magnitude
            if Root < ClosestDistance then
                ClosestPlayer = Player
                ClosestDistance = Root
            end
        end
    end
    return ClosestPlayer
end

-- Check if chat input is focused
local function isChatFocused()
    return UserInputService:GetFocusedTextBox() ~= nil
end

-- Toggle Aimbot
Mouse.KeyDown:Connect(function(key)
    if isChatFocused() then return end -- Exit if chat is focused
    if key == getgenv().JuliMade.Aimbot.Keybind:lower() then
        Player = getgenv().JuliMade.Aimbot.hot == 'toggle' and not Player and GetClosestPlayer() or nil
    end
end)

-- Run Aimbot
RunService.RenderStepped:Connect(function()
    if not Player or not getgenv().JuliMade.Aimbot.Enabled then return end
    local Hitpart = Player.Character:FindFirstChild(getgenv().JuliMade.Aimbot.Hitpart)
    if not Hitpart then return end

    -- Calculate the target position
    local targetPosition = Hitpart.Position + Hitpart.Velocity * Vector3.new(
        getgenv().JuliMade.Aimbot.Prediction.X, 
        getgenv().JuliMade.Aimbot.Prediction.Y, 
        getgenv().JuliMade.Aimbot.Prediction.X
    )

    -- Calculate distance to the target
    local distance = (LocalPlayer.Character.HumanoidRootPart.Position - Player.Character.HumanoidRootPart.Position).Magnitude
    local predictionAdjustment = 0

    -- Distance-based prediction adjustment
    if getgenv().JuliMade.Aimbot.DistancePredictionEnabled then
        if distance < getgenv().JuliMade.Aimbot.MaxDistance then
            predictionAdjustment = (getgenv().JuliMade.Aimbot.BasePrediction * (1 - (distance / getgenv().JuliMade.Aimbot.MaxDistance)))
        else
            predictionAdjustment = 0
        end
    end

    -- Adjust prediction based on distance
    targetPosition = targetPosition + Hitpart.Velocity * predictionAdjustment

    -- Interpolate camera's CFrame for smooth aiming if enabled
    local currentCFrame = Camera.CFrame
    local targetCFrame = CFrame.new(currentCFrame.Position, targetPosition)

    -- Smoothly transition the camera's CFrame if smoothness is enabled
    if getgenv().JuliMade.Aimbot.SmoothnessEnabled then
        Camera.CFrame = currentCFrame:Lerp(targetCFrame, getgenv().JuliMade.Aimbot.Smoothness)
    else
        Camera.CFrame = targetCFrame
    end
end)

-- Fly Functionality
local function StartFly()
    if flying then return end
    flying = true

    -- Create BodyGyro and BodyVelocity for flying
    BodyGyro = Instance.new('BodyGyro')
    BodyGyro.P = 9e4
    BodyGyro.MaxTorque = Vector3.new(9e4, 9e4, 9e4)
    BodyGyro.CFrame = LocalPlayer.Character.HumanoidRootPart.CFrame
    BodyGyro.Parent = LocalPlayer.Character.HumanoidRootPart

    BodyVelocity = Instance.new('BodyVelocity')
    BodyVelocity.Velocity = Vector3.new(0, 0, 0)
    BodyVelocity.MaxForce = Vector3.new(9e4, 9e4, 9e4)
    BodyVelocity.Parent = LocalPlayer.Character.HumanoidRootPart

    -- Fly movement control
    RunService.RenderStepped:Connect(function()
        if not flying then return end
        local direction = Vector3.new(0, 0, 0)

        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            direction = direction + (Workspace.CurrentCamera.CFrame.LookVector)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            direction = direction - (Workspace.CurrentCamera.CFrame.LookVector)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            direction = direction - (Workspace.CurrentCamera.CFrame.RightVector)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            direction = direction + (Workspace.CurrentCamera.CFrame.RightVector)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            direction = direction + Vector3.new(0, 1, 0)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
            direction = direction - Vector3.new(0, 1, 0)
        end

        BodyVelocity.Velocity = direction * getgenv().JuliMade.Fly.FlySpeed
        BodyGyro.CFrame = Workspace.CurrentCamera.CFrame
    end)
end

-- Function to stop flying
local function StopFly()
    flying = false
    if BodyGyro then BodyGyro:Destroy() end
    if BodyVelocity then BodyVelocity:Destroy() end
end

-- Handle key presses for fly toggle
UserInputService.InputBegan:Connect(function(input)
    if isChatFocused() then return end -- Exit if chat is focused
    if input.KeyCode == Enum.KeyCode[getgenv().JuliMade.Fly.FlyKeybind] then
        getgenv().JuliMade.Fly.FlyEnabled = not getgenv().JuliMade.Fly.FlyEnabled
        if getgenv().JuliMade.Fly.FlyEnabled then
            StartFly()
        else
            StopFly()
        end
    end

    -- Handle auto clicker key presses
    if input.KeyCode == Enum.KeyCode[getgenv().JuliMade.Extra.AutoClicker.Keybind] then
        if getgenv().JuliMade.Extra.AutoClicker.Mode == 'toggle' then
            getgenv().JuliMade.Extra.AutoClicker.Enabled = not getgenv().JuliMade.Extra.AutoClicker.Enabled
        else
            getgenv().JuliMade.Extra.AutoClicker.Enabled = true
        end
        -- Start the auto clicker if enabled
        if getgenv().JuliMade.Extra.AutoClicker.Enabled then
            spawn(function()
                while getgenv().JuliMade.Extra.AutoClicker.Enabled do
                    if not (LocalPlayer.Backpack:FindFirstChild("Knife") or LocalPlayer.Character:FindFirstChild("Knife")) then
                        Mouse1Click()
                    end
                    wait(getgenv().JuliMade.Extra.AutoClicker.Delay)
                end
            end)
        end
    end
end)

-- Stop auto clicking if the key is released when in hold mode
UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode[getgenv().JuliMade.Extra.AutoClicker.Keybind] and getgenv().JuliMade.Extra.AutoClicker.Mode == 'hold' then
        getgenv().JuliMade.Extra.AutoClicker.Enabled = false
    end
end)

-- Noclip Functionality
local function Noclip()
    if not getgenv().JuliMade.Extra.Noclip then return end
    local character = LocalPlayer.Character
    if not character then return end

    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            if getgenv().JuliMade.Extra.ThroughtWalls then
                part.CanCollide = false
            else
                -- Only disable collision for non-wall parts
                if part.Name ~= "Wall" and not part.Name:match("Wall") then
                    part.CanCollide = false
                end
            end
        end
    end
end

-- ThroughtWalls Functionality
local function ThroughtWalls()
    if not getgenv().JuliMade.Extra.ThroughtWalls then return end
    local character = LocalPlayer.Character
    if not character then return end

    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
end

-- Run Noclip and ThroughtWalls
RunService.RenderStepped:Connect(function()
    Noclip()
    ThroughtWalls()
end)

-- Stop flying if key is released (optional)
UserInputService.InputEnded:Connect(function(input)
    -- Handle key releases if needed
end)
